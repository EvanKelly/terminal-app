<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Terminal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: #00ff00;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .terminal-container {
            width: 90vw;
            height: 90vh;
            background-color: #000;
            border: 2px solid #00ff00;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .terminal-header {
            background-color: #001100;
            border-bottom: 1px solid #00ff00;
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .terminal-title {
            color: #00ff00;
            font-weight: bold;
        }

        .terminal-controls {
            display: flex;
            gap: 8px;
        }

        .control {
            width: 20px;
            height: 20px;
            border: 1px solid #00ff00;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        .control:hover {
            background-color: #00ff00;
            color: #000;
        }

        .print-button {
            background-color: transparent;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 4px 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-right: 10px;
        }

        .print-button:hover {
            background-color: #00ff00;
            color: #000;
        }

        .print-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .terminal-body {
            flex: 1;
            padding: 15px;
            display: flex;
            flex-direction: column;
            background-color: #000;
            position: relative;
        }

        .terminal-output {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            margin-bottom: 10px;
            font-size: 16px;
            line-height: 1.4;
            max-height: calc(90vh - 120px);
            padding-right: 5px;
        }

        .output-line {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .terminal-input-line {
            display: flex;
            align-items: center;
            gap: 10px;
            border-top: 1px solid #00ff00;
            padding-top: 10px;
        }

        .prompt {
            color: #00ff00;
            font-weight: bold;
            font-size: 16px;
        }

        .terminal-input {
            flex: 1;
            background-color: transparent;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            outline: none;
            caret-color: #00ff00;
        }

        .terminal-input::placeholder {
            color: #004400;
        }

        .terminal-output::-webkit-scrollbar {
            width: 10px;
        }

        .terminal-output::-webkit-scrollbar-track {
            background: #001100;
            border-radius: 5px;
        }

        .terminal-output::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 5px;
            border: 1px solid #003300;
        }

        .terminal-output::-webkit-scrollbar-thumb:hover {
            background: #00cc00;
        }

        .terminal-output::-webkit-scrollbar-corner {
            background: #001100;
        }

        .matrix-rain {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .matrix-char {
            position: absolute;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            animation: matrix-fall 3s linear infinite;
        }

        @keyframes matrix-fall {
            0% {
                transform: translateY(-100vh);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <div class="terminal-header">
            <div class="terminal-title">Evan and Emily's Poetry Guestbook</div>
            <div class="terminal-controls">
                <button class="print-button" id="printButton" disabled>Print Last Response</button>
            </div>
        </div>
        <div class="terminal-body">
            <div class="terminal-output" id="terminalOutput">
                <div class="output-line">Welcome to the Poetry Guestbook. You can use the terminal to craft a poem to save for Ev & Em</div>
                <div class="output-line">Just type your message and press Enter to chat with the AI poet!</div>
                <div class="output-line">Type 'help' for available commands</div>
                <div class="output-line"></div>
            </div>
            <div class="terminal-input-line">
                <span class="prompt">$</span>
                <input type="text" id="terminalInput" class="terminal-input" placeholder="Type your message to the AI poet..." autocomplete="off">
            </div>
        </div>
    </div>

    <!-- Load configuration -->
    <script src="config.js"></script>
    
    <script>
        class RetroTerminal {
            constructor() {
                this.terminalOutput = document.getElementById('terminalOutput');
                this.terminalInput = document.getElementById('terminalInput');
                this.printButton = document.getElementById('printButton');
                this.commandHistory = [];
                this.historyIndex = -1;
                this.isMatrixActive = false;
                this.chatHistory = []; // Store chat conversation history
                this.lastChatGPTResponse = null; // Store the last ChatGPT response
                this.userContext = {
                    name: 'Terminal User',
                    preferences: [],
                    sessionStart: new Date(),
                    commandsUsed: []
                };
                
                this.init();
            }

            init() {
                this.terminalInput.focus();
                this.setupEventListeners();
                this.addOutputLine('System initialized. Ready for commands.');
            }

            setupEventListeners() {
                this.terminalInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.processCommand();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        this.navigateHistory('up');
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        this.navigateHistory('down');
                    }
                });


                // Add print button event listener
                this.printButton.addEventListener('click', () => {
                    this.printLastResponse();
                });
            }

            processCommand() {
                const command = this.terminalInput.value.trim();
                if (!command) return;

                this.addOutputLine(`$ ${command}`);
                this.commandHistory.push(command);
                this.historyIndex = this.commandHistory.length;

                const parts = command.split(' ');
                const cmd = parts[0].toLowerCase();
                const args = parts.slice(1);

                switch (cmd) {
                    case 'help':
                        this.showHelp();
                        break;
                    case 'clear':
                        this.clearTerminal();
                        break;
                    case 'date':
                        this.showDate();
                        break;
                    case 'echo':
                        this.echo(args.join(' '));
                        break;
                    case 'matrix':
                        this.toggleMatrix();
                        break;
                    case 'ls':
                    case 'dir':
                        this.listFiles();
                        break;
                    case 'pwd':
                        this.showCurrentDirectory();
                        break;
                    case 'whoami':
                        this.showUser();
                        break;
                    case 'neofetch':
                        this.showSystemInfo();
                        break;
                    case 'chat':
                        this.chatWithGPT(args.join(' '));
                        break;
                    case 'clear-chat':
                        this.clearChatHistory();
                        break;
                    case 'set-name':
                        this.setUserName(args.join(' '));
                        break;
                    case 'scroll-top':
                        this.scrollToTop();
                        break;
                    case 'scroll-bottom':
                        this.scrollToBottom();
                        break;
                    default:
                        // Default behavior: send any unrecognized command to ChatGPT
                        this.chatWithGPT(command);
                }

                this.terminalInput.value = '';
                this.scrollToBottom();
            }

            addOutputLine(text) {
                const line = document.createElement('div');
                line.className = 'output-line';
                line.textContent = text;
                this.terminalOutput.appendChild(line);
                this.scrollToBottom();
            }

            scrollToBottom() {
                this.terminalOutput.scrollTo({
                    top: this.terminalOutput.scrollHeight,
                    behavior: 'smooth'
                });
            }

            scrollToTop() {
                this.terminalOutput.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            }

            navigateHistory(direction) {
                if (this.commandHistory.length === 0) return;

                if (direction === 'up') {
                    if (this.historyIndex > 0) {
                        this.historyIndex--;
                    }
                } else if (direction === 'down') {
                    if (this.historyIndex < this.commandHistory.length - 1) {
                        this.historyIndex++;
                    } else {
                        this.historyIndex = this.commandHistory.length;
                        this.terminalInput.value = '';
                        return;
                    }
                }

                if (this.historyIndex >= 0 && this.historyIndex < this.commandHistory.length) {
                    this.terminalInput.value = this.commandHistory[this.historyIndex];
                }
            }

            showHelp() {
                this.addOutputLine('Available commands:');
                this.addOutputLine('  help     - Show this help message');
                this.addOutputLine('  clear    - Clear the terminal');
                this.addOutputLine('  clear-chat - Clear chat conversation history');
                this.addOutputLine('  date     - Show current date and time');
                this.addOutputLine('  echo     - Echo a message');
                this.addOutputLine('  matrix   - Toggle matrix rain effect');
                this.addOutputLine('  ls/dir   - List files');
                this.addOutputLine('  pwd      - Show current directory');
                this.addOutputLine('  whoami   - Show user info');
                this.addOutputLine('  neofetch - Show system information');
                this.addOutputLine('  set-name - Set your name');
                this.addOutputLine('  scroll-top/scroll-bottom - Navigate terminal');
                this.addOutputLine('');
                this.addOutputLine('Any other text will be sent to ChatGPT for poem generation!');
            }

            clearTerminal() {
                this.terminalOutput.innerHTML = '';
                this.addOutputLine('Terminal cleared.');
            }

            showDate() {
                const now = new Date();
                this.addOutputLine(`Current date and time: ${now.toLocaleString()}`);
            }

            echo(message) {
                if (message) {
                    this.addOutputLine(message);
                } else {
                    this.addOutputLine('Usage: echo [message]');
                }
            }

            toggleMatrix() {
                if (this.isMatrixActive) {
                    this.stopMatrix();
                } else {
                    this.startMatrix();
                }
            }

            startMatrix() {
                this.isMatrixActive = true;
                this.addOutputLine('Matrix rain effect activated...');
                
                const matrixContainer = document.createElement('div');
                matrixContainer.className = 'matrix-rain';
                document.querySelector('.terminal-body').appendChild(matrixContainer);

                const chars = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
                
                const createMatrixChar = () => {
                    if (!this.isMatrixActive) return;
                    
                    const char = document.createElement('div');
                    char.className = 'matrix-char';
                    char.textContent = chars[Math.floor(Math.random() * chars.length)];
                    char.style.left = Math.random() * 100 + '%';
                    char.style.animationDelay = Math.random() * 2 + 's';
                    matrixContainer.appendChild(char);

                    setTimeout(() => {
                        if (char.parentNode) {
                            char.parentNode.removeChild(char);
                        }
                    }, 3000);
                };

                this.matrixInterval = setInterval(createMatrixChar, 100);
            }

            stopMatrix() {
                this.isMatrixActive = false;
                clearInterval(this.matrixInterval);
                const matrixContainer = document.querySelector('.matrix-rain');
                if (matrixContainer) {
                    matrixContainer.remove();
                }
                this.addOutputLine('Matrix rain effect deactivated.');
            }

            listFiles() {
                this.addOutputLine('Directory listing:');
                this.addOutputLine('  index.html     - Main application file');
                this.addOutputLine('  style.css      - Terminal styling');
                this.addOutputLine('  script.js      - Terminal logic');
                this.addOutputLine('  README.md      - Documentation');
                this.addOutputLine('  package.json   - Project configuration');
            }

            showCurrentDirectory() {
                this.addOutputLine('/home/user/terminal-app');
            }

            showUser() {
                this.addOutputLine('user@retro-terminal:~$');
            }

            showSystemInfo() {
                this.addOutputLine('Retro Terminal v1.0');
                this.addOutputLine('OS: Retro Terminal OS');
                this.addOutputLine('Kernel: 5.4.0-retro');
                this.addOutputLine('Shell: bash 5.0.17');
                this.addOutputLine('Terminal: Retro Terminal v1.0');
                this.addOutputLine('CPU: Intel 8086 (emulated)');
                this.addOutputLine('Memory: 640KB');
                this.addOutputLine('Resolution: 80x25');
                this.addOutputLine('Colors: Green on Black');
            }

            clearChatHistory() {
                this.chatHistory = [];
                this.lastChatGPTResponse = null;
                this.printButton.disabled = true;
                this.addOutputLine('Chat conversation history cleared.');
            }

            printLastResponse() {
                if (!this.lastChatGPTResponse) {
                    this.addOutputLine('No response to print. Generate a poem first!');
                    return;
                }

                try {
                    // Create a new window for printing
                    const printWindow = window.open('', '_blank', 'width=800,height=600');
                    
                    if (!printWindow) {
                        this.addOutputLine('Error: Pop-up blocked. Please allow pop-ups for this site.');
                        return;
                    }

                    printWindow.document.write(`
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <title>Poem</title>
                            <style>
                                body {
                                    font-family: 'Courier New', monospace;
                                    background-color: white;
                                    color: black;
                                    padding: 20px;
                                    line-height: 1.6;
                                    margin: 0;
                                }
                                .poem {
                                    white-space: pre-wrap;
                                    font-size: 16px;
                                    text-align: center;
                                    max-width: 600px;
                                    margin: 0 auto;
                                }
                                .controls {
                                    margin-top: 30px;
                                    text-align: center;
                                }
                                .controls button {
                                    background-color: #007bff;
                                    color: white;
                                    border: none;
                                    padding: 10px 20px;
                                    margin: 0 10px;
                                    cursor: pointer;
                                    border-radius: 4px;
                                    font-size: 14px;
                                }
                                .controls button:hover {
                                    background-color: #0056b3;
                                }
                                @media print {
                                    .controls { display: none; }
                                    body { margin: 0; padding: 20px; }
                                }
                            </style>
                        </head>
                        <body>
                            <div class="poem">${this.lastChatGPTResponse}</div>
                            <div class="controls">
                                <button onclick="window.print()">Print</button>
                                <button onclick="window.close()">Close</button>
                            </div>
                        </body>
                        </html>
                    `);
                    printWindow.document.close();
                    
                    this.addOutputLine('Print window opened. The poem is ready for printing.');
                } catch (error) {
                    this.addOutputLine('Error opening print window: ' + error.message);
                }
            }

            setUserName(name) {
                if (name) {
                    this.userContext.name = name;
                    this.addOutputLine(`User name set to: ${name}`);
                } else {
                    this.addOutputLine('Usage: set-name [your name]');
                }
            }

            /**
             * Send a message to OpenAI's ChatGPT API and display the response.
             * @param {string} message
             */
            async chatWithGPT(message) {
                if (!message) {
                    this.addOutputLine('Usage: chat [message]');
                    return;
                }
                this.addOutputLine('ChatGPT: thinking...');
                this.scrollToBottom();
                
                // Get API key from config file
                const OPENAI_API_KEY = window.CONFIG?.OPENAI_API_KEY;
                if (!OPENAI_API_KEY || OPENAI_API_KEY === 'YOUR_OPENAI_API_KEY_HERE') {
                    this.addOutputLine('Error: Please configure your OpenAI API key in config.js');
                    this.addOutputLine('Copy config.template.js to config.js and add your API key');
                    return;
                }
                
                // Add user message to chat history
                this.chatHistory.push({ role: 'user', content: message });
                
                // Limit chat history to last 10 messages to avoid token limits
                if (this.chatHistory.length > 10) {
                    this.chatHistory = this.chatHistory.slice(-10);
                }
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${OPENAI_API_KEY}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',
                            messages: [
                                { 
                                    role: 'system', 
                                    content: `You are a poet integrated into a retro-style terminal interface. 
                                    
CONTEXT:
- You're running in a web-based terminal with a green-on-black color scheme
- Users interact with you by typing 'chat [message]' commands
- You are set up at the wedding of Evan Kelly and Emily Ahn
- Evan and Emily are getting married on September 27th, 2025 in Zion, Utah
- Evan and Emily have a dog named Kogi who is 40lbs and black and has really nice ears
- Your role at this wedding is to generate love poems using the prompt of each guest that should describe features of the type of poem they want you to generate
- You should help each guest generate a poem that makes the guest think about love in a positive way
- Evan is from Richmond, Virginia and went to Princeton University
- Evan was on the swim team at Princeton University
- Emily is from Boston, Massachusetts and went to Columbia University after transferring from Northwestern University
- Emily was on the sailing team at Northwestern and Columbia
- Evan and Emily used to live in New York City, but moved to Salt Lake City during COVID
- Evan and Emily have traveled to Cambodia, Korea, France, London, Kenya, Japan, Hokkaido, Croatia, Norway, Spain, and Germany together
- Emily loves books about feelings and trash reality tv
- Evan loves science fiction and fantasy books
- Kogi is the most important thing to Evan and Emily.
- Evan and Emily call Kogi "little mouse"
- Kogi is 5 years old
- Kogi is from West Virginia
- The poems you generate will be printed from a small printer, so make sure when you answer with the poem it is it's own response with no other comments

RESPONSE STYLE:
- For the first response with a new guest, say "Hello, welcome to Kogi's Love Poem Generator, what kind of poem can I write for you today? Tell me your name and some relevant details that I can use when writing"
- Should be in a poem format that is unique to the guests prompts and is romantic
- You should ask guests their name and use it in the poem
- you should ask guests what style of poem they want you to generate
- you should ask guests what the theme of the poem should be
- when you respond with the poem, don't include anything before the poem starts or after the poem except the inscription
- You can ask guest for details, but don't ask questions in the generated poem. The generated poem should be about love and include the details they gave you. Feel free to ask for clarification before generating the poem.
- you should ask guests important details about Evan and Emily they want to include
- If you do not have enough information about the guest to generate a unique poem, ask for more information
- If the guest asks to include details about Evan and Emily, you can, but otherwise don't use the context you know about Evan and Emily
- In the final poem response, include line breaks that match the meter of the poem, but for other responses use normal punctuation and line breaks.
- Sign the poem with an inscription that says "For [the guest's name]" and the date and place of the wedding without any dashes.
- each poem you generate should be unique for each guest`
                                },
                                ...this.chatHistory // Include conversation history
                            ]
                        })
                    });
                    if (!response.ok) {
                        throw new Error('API error: ' + response.status);
                    }
                    const data = await response.json();
                    // Remove the 'thinking...' line
                    const outputLines = this.terminalOutput.querySelectorAll('.output-line');
                    if (outputLines.length > 0 && outputLines[outputLines.length - 1].textContent === 'ChatGPT: thinking...') {
                        outputLines[outputLines.length - 1].remove();
                    }
                    const reply = data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content
                        ? data.choices[0].message.content.trim()
                        : '[No response from ChatGPT]';
                    
                    // Add assistant response to chat history
                    this.chatHistory.push({ role: 'assistant', content: reply });
                    
                    // Store the last ChatGPT response for printing
                    this.lastChatGPTResponse = reply;
                    
                    // Enable the print button
                    this.printButton.disabled = false;
                    
                    // Display the ChatGPT response with preserved line breaks
                    const replyLines = reply.split('\n');
                    this.addOutputLine('ChatGPT:');
                    replyLines.forEach(line => {
                        if (line.trim()) {
                            this.addOutputLine('  ' + line);
                        } else {
                            this.addOutputLine(''); // Empty line for spacing
                        }
                    });
                } catch (err) {
                    // Remove the 'thinking...' line
                    const outputLines = this.terminalOutput.querySelectorAll('.output-line');
                    if (outputLines.length > 0 && outputLines[outputLines.length - 1].textContent === 'ChatGPT: thinking...') {
                        outputLines[outputLines.length - 1].remove();
                    }
                    this.addOutputLine('Error contacting ChatGPT: ' + err.message);
                }
            }
        }

        // Initialize the terminal when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new RetroTerminal();
        });
    </script>
</body>
</html> 